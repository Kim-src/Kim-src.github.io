---
title: 상속, 추상화, 인터페이스 및 접근제한자의 상호작용 관계
date: 2024-06-10 18:00:00 +09:00
categories: [1. Fundamental, Java]
tags: [Java, Fundamental, Inheritance, Abstraction, Interface, Access Modifiers, Superclass, Subclass, Abstract Class, Abstract Method, Encapsulation, Encapsulation]
---

<!-- 2024-06-10 글 작성 시작; 2099-01-01 페이지 호출 완료 -->
<h2>강의 내용 복습 : 코리아IT 신촌점 강의 (2024-05-02,03 강의)</h2>
> - Tool :  
<img alt="Java" src="https://img.shields.io/badge/-Java-007396?style=flat-square&logo=java&logoColor=white" />
<img alt="Eclipse" src="https://img.shields.io/badge/-Eclipse-2C2255?style=flat-square&logo=eclipse&logoColor=white" />

<br>

### 🔔 접근제한자
### 📌 접근제한자 개념
> - 접근제한자는 객체 지향 프로그래밍에 있어서 캡슐화 및 데이터 보호에 있어 필수적입니다.
> - <a href="https://kim-src.github.io/posts/%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90,-%EC%BA%A1%EC%8A%90%ED%99%94,-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9,-Getter,-Setter-%EC%9D%98%EB%AF%B8/#-%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90">접근제한자는 public, private, protected로 구분되며 링크된 글</a>에 상세 설명이 있습니다.
> - public : 외부로부터의 자유로운 접근이 가능합니다.
> - private : 동일 클래스 내부에서만 접근 가능합니다.
> - protected : 동일 패키지 내부, 해당 클래스를 상속 받은 자식 클래스에서 접근 가능합니다.
> - default : 동일 패키지 내부에서만 접근 가능합니다.

### 📌 접근제한자와의 상호작용
> - 이들 접근제한자는 상속-추상화-인터페이스와 밀접한 관련이 있습니다.
> - public : 인터페이스의 메서드는 보통 public으로 선언됩니다.
> - private : 클래스의 내부 구현을 숨길 수 있기 때문에 견고하게 추상화 할 수 있습니다.
> - protected : 자식 클래스에서 protected 멤버에 접근할 수 있습니다.

<br>

### 🔔 상속(Inheritance)
### 📌 상속 소개
> - 상속은 객체 지향 프로그래밍의 핵심 개념 중 하나입니다.
> - 상속은 하나의 클래스가 다른 클래스의 속성 또는 메서드를 사용할 수 있는 기능입니다.
> - 그러므로 상속은 캡슐화 된 객체를 계층화하여 코드의 재사용성을 높입니다.
> - 예를들면 Person 객체를 상속받는 Student, Actor, Employee 객체가 존재할 수 있습니다.
> - 또는 Animal 객체를 상속받는 Dog, Cat, Tiger 객체가 존재할 수 있습니다.

### 📌 상속 계층화
> - 상속 관계의 객체는 상하 계층이 구분되어 있습니다.
> - 상위 계층은 상위 클래스(Superclass) 또는 부모 클래스(Parent Class)라고 합니다.
> - 하위 계층은 하위 클래스(Subclass) 또는 자식 클래스(Child Class)라고 합니다.
> - 상위 클래스는 속성 또는 기능을 하위 클래스에 상속합니다.
> - 하위 클래스는 속성 또는 기능을 상위 클래스로부터 상속 받습니다.

### 📌 상속 특징
#### 🚩 오버라이딩(Overriding)
> - 상위 클래스의 메서드 기능을 하위 클래스의 성격에 맞게 재정의 할 수 있습니다.
> - 이때 명시적으로 @Override 어노테이션을 사용하는 것이 좋습니다.
> - 아래는 오버라이딩에 대한 예시입니다.

``` java
public class bark {

	public static void main(String[] args) {
		
		class Animal {
		    public void bark() {
		        System.out.println("");
		    }
		}

		// 기본 생성자 생성
		Animal animal = new Animal();
		
		// Animal 객체의 bark 메서드 사용
		animal.bark();

		class Dog extends Animal {
		    @Override
		    public void bark() {
		        System.out.println("멍멍");
		    }
		}

		// 기본 생성자 생성
		Dog dog = new Dog();
		
		// Dog 객체의 bark 메서드 이용
		dog.bark();

		class Cat extends Animal {
		    @Override
		    public void bark() {
		        System.out.println("야옹");
		    }
		}

		// 기본 생성자 생성
		Cat cat = new Cat();
		// Cat 객체의 bark 메서드 이용
		cat.bark();
		
	}
	
}
```

#### 🚩 super 키워드
> - super 키워드를 이용하여 상위 클래스의 기능 또는 생성자를 호출할 수 있습니다.
> - super 키워드에 대한 예시는 아래 상속 구현 란에 있습니다.

#### 🚩 final 키워드
> - final 키워드로 선언된 클래스는 상속될 수 없습니다.
> - final 키워드로 선언된 메서드는 오버라이딩 될 수 없습니다.
> - 즉, final 키워드로 선언된 클래스 또는 메서드는 변경될 수 없습니다.

#### 🚩 단일 상속
> - Java에서는 클래스의 단일 상속만을 허용합니다.
> - 즉, 하위 클래스는 하나의 상위 클래스로부터만 메서드 등을 상속받을 수 있습니다.
> - 대신 인터페이스를 이용하면 다중 상속과 유사한 기능을 구현할 수 있습니다.

### 📌 상속 구현
> - 클래스 간의 상속 방법은 매우 간단하며 extends 키워드를 사용하면 됩니다.
> - 아래는 상속 기능을 구현한 예시입니다.

#### 🚩 Person 객체 구현

``` java
// 다양하게 응용할 Person 객체를 정의하였습니다.
public class Person {
	
	// 핵심 요소는 private으로 선언하였습니다.
	private String name;
	private int age;
	private String gender;
	
	// 각 요소에 대한 getter/setter 메서드는 public으로 선언하였습니다.
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}

}
```

#### 🚩 Actor 객체 구현

``` java
public class Actor extends Person {
	
	private String myMovie;
	
	// 생성자를 정의하였습니다.
	public Actor(String name, int age, String gender, String myMovie) {
		super(name, age, gender);
		this.setMyMovie(myMovie);
	}

	// myMovie에 대한 getter/setter 메서드입니다.
	public String getMyMovie() {
		return myMovie;
	}

	public void setMyMovie(String myMovie) {
		this.myMovie = myMovie;
	}
	
}
```

#### 🚩 Employee 객체 구현

``` java
public class Employee extends Person {
	
	public Employee(String name, int age, String gender, String company) {
		super(name, age, gender);
		this.setCompany(company);
	}

	private String company;

	public String getCompany() {
		return company;
	}

	public void setCompany(String company) {
		this.company = company;
	}
	
}
```

<br>

### 🔔 추상화(Abstraction)
### 📌 부제목
> - 글 내용

<br>

### 🔔 인터페이스(Interface)
### 📌 부제목
> - 글 내용

<br>
<br>
<br>

---
title: 상속, 추상화, 인터페이스 및 접근제한자의 상호작용 관계
date: 2024-06-10 18:00:00 +09:00
categories: [1. Fundamental, Java]
tags: [Java, Fundamental, Inheritance, Abstraction, Interface, Access Modifiers, Superclass, Subclass, Abstract Class, Abstract Method, Encapsulation, Encapsulation]
---

<!-- 2024-06-10 글 작성 시작; 2099-01-01 페이지 호출 완료 -->
<h2>강의 내용 복습 : 코리아IT 신촌점 강의 (2024-05-02,03 강의)</h2>
> - Tool :  
<img alt="Java" src="https://img.shields.io/badge/-Java-007396?style=flat-square&logo=java&logoColor=white" />
<img alt="Eclipse" src="https://img.shields.io/badge/-Eclipse-2C2255?style=flat-square&logo=eclipse&logoColor=white" />

<br>

### 🔔 접근제한자
### 📌 접근제한자 개념
> - 접근제한자는 객체 지향 프로그래밍에 있어서 캡슐화 및 데이터 보호에 있어 필수적입니다.
> - <a href="https://kim-src.github.io/posts/%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90,-%EC%BA%A1%EC%8A%90%ED%99%94,-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9,-Getter,-Setter-%EC%9D%98%EB%AF%B8/#-%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90">접근제한자는 public, private, protected로 구분되며 링크된 글</a>에 상세 설명이 있습니다.
> - public : 외부로부터의 자유로운 접근이 가능합니다.
> - private : 동일 클래스 내부에서만 접근 가능합니다.
> - protected : 동일 패키지 내부, 해당 클래스를 상속 받은 자식 클래스에서 접근 가능합니다.
> - default : 동일 패키지 내부에서만 접근 가능합니다.

### 📌 접근제한자와의 상호작용
> - 이들 접근제한자는 상속-추상화-인터페이스와 밀접한 관련이 있습니다.
> - public : 인터페이스의 메서드는 보통 public으로 선언됩니다.
> - private : 클래스의 내부 구현을 숨길 수 있기 때문에 견고하게 추상화 할 수 있습니다.
> - protected : 자식 클래스에서 protected 멤버에 접근할 수 있습니다.

<br>

### 🔔 상속(Inheritance)
### 📌 상속 소개
> - 상속은 하나의 클래스가 다른 클래스의 속성 또는 메서드를 사용할 수 있는 기능입니다.
> - 그러므로 상속은 캡슐화 된 객체를 계층화하여 코드의 재사용성을 높입니다.
> - 예를들면 Person 객체를 상속받는 Student, Actor, Employee 객체가 존재할 수 있습니다.
> - 또는 Animal 객체를 상속받는 Dog, Cat, Tiger 객체가 존재할 수 있습니다.

### 📌 상속 계층화
> - 상속 관계의 객체는 상하 계층이 구분되어 있습니다.
> - 상위 계층은 상위 클래스(Superclass) 또는 부모 클래스(Parent Class)라고 합니다.
> - 하위 계층은 하위 클래스(Subclass) 또는 자식 클래스(Child Class)라고 합니다.
> - 상위 클래스는 속성 또는 기능을 하위 클래스에 상속합니다.
> - 하위 클래스는 속성 또는 기능을 상위 클래스로부터 상속 받습니다.
> - 하위 클래스 정의 시 extends 키워드를 이용하여 상위 클래스를 상속시킵니다.

### 📌 상속 특징
#### 🚩 오버라이딩(Overriding)
> - 상위 클래스의 메서드 기능을 하위 클래스의 성격에 맞게 재정의 할 수 있습니다.
> - 이때 명시적으로 @Override 어노테이션을 사용하는 것이 좋습니다.
> - 아래는 오버라이딩에 대한 예시입니다.

``` java
public class bark {

	public static void main(String[] args) {
		
		class Animal {
		    public void bark() {
		        System.out.println("");
		    }
		}

		// 기본 생성자 생성
		Animal animal = new Animal();
		
		// Animal 객체의 bark 메서드 사용
		animal.bark();

		class Dog extends Animal {
		    @Override
		    public void bark() {
		        System.out.println("멍멍");
		    }
		}

		// 기본 생성자 생성
		Dog dog = new Dog();
		
		// Dog 객체의 bark 메서드 이용
		dog.bark();

		class Cat extends Animal {
		    @Override
		    public void bark() {
		        System.out.println("야옹");
		    }
		}

		// 기본 생성자 생성
		Cat cat = new Cat();
		// Cat 객체의 bark 메서드 이용
		cat.bark();
		
	}
	
}
```

#### 🚩 super 키워드
> - super 키워드를 이용하여 상위 클래스의 기능 또는 생성자를 호출할 수 있습니다.
> - super 키워드에 대한 예시는 아래 상속 구현 란에 있습니다.

#### 🚩 final 키워드
> - final 키워드로 선언된 클래스는 상속될 수 없습니다.
> - final 키워드로 선언된 메서드는 오버라이딩 될 수 없습니다.
> - 즉, final 키워드로 선언된 클래스 또는 메서드는 변경될 수 없습니다.

#### 🚩 단일 상속
> - Java에서는 클래스의 단일 상속만을 허용합니다.
> - 즉, 하위 클래스는 하나의 상위 클래스로부터만 메서드 등을 상속받을 수 있습니다.
> - 대신 인터페이스를 이용하면 다중 상속과 유사한 기능을 구현할 수 있습니다.

### 📌 상속 구현
> - 클래스 간의 상속 방법은 매우 간단하며 extends 키워드를 사용하면 됩니다.
> - 아래는 상속 기능을 구현한 예시입니다.

#### 🚩 Person 객체 구현

``` java
// 다양하게 응용할 Person 객체를 정의하였습니다.
public class Person {
	
	// 핵심 요소는 private으로 선언하였습니다.
	private String name;
	private int age;
	private String gender;
	
	// 각 요소에 대한 getter/setter 메서드는 public으로 선언하였습니다.
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}

}
```

#### 🚩 Actor 객체 구현

``` java
public class Actor extends Person {
	
	private String myMovie;
	
	// 생성자를 정의하였습니다.
	public Actor(String name, int age, String gender, String myMovie) {
		super(name, age, gender);
		this.setMyMovie(myMovie);
	}

	// myMovie에 대한 getter/setter 메서드입니다.
	public String getMyMovie() {
		return myMovie;
	}

	public void setMyMovie(String myMovie) {
		this.myMovie = myMovie;
	}
	
}
```

#### 🚩 Employee 객체 구현

``` java
public class Employee extends Person {
	
	public Employee(String name, int age, String gender, String company) {
		super(name, age, gender);
		this.setCompany(company);
	}

	private String company;

	public String getCompany() {
		return company;
	}

	public void setCompany(String company) {
		this.company = company;
	}
	
}
```

<br>

### 🔔 추상화(Abstraction)
### 📌 추상화 소개
> - 추상화는 단어 그대로 실제 세계의 복잡한 무언가를 단순화하는 과정입니다.
> - 추상화는 프로그래밍에 필요한 기능 또는 데이터를 강조하고 세부 사항은 숨기는 과정입니다.
> - 개발자는 추상화를 통해 코드의 복잡성을 관리하고 유지/보수를 용이하게 할 수 있습니다.
> - 추상화는 크게 데이터 추상화 및 프로세스 추상화로 구분할 수 있습니다.

### 📌 데이터 추상화(data abstraction)
> - 데이터 추상화는 전체 모델링 내용 중 일부만 사용자에게 제공하는 개념입니다.
> - 데이터 추상화는 클래스 정의 과정에서 이뤄집니다.
> - 데이터 추상화는 어떤 속성 또는 기능이 외부로 노출될지 결정하고 세부사항은 숨깁니다.
> - 예를들면 자동차의 세부 구조를 다 공개하는 것이 아니라 일부 기능만 공개하는 것입니다.
> - 예를들면 accelerate()이나 brake() 메서드만을 사용자에게 제공하는 방식입니다.
> - 예를들면 Java에서 기본적으로 제공하는 List 인터페이스가 있습니다.

### 📌 프로세스 추상화(process abstraction)
> - 프로세스 추상화는 복잡한 로직을 하나의 메서드 등으로 캡슐화하는 개념입니다.
> - 예를들면 서버에 데이터를 요청하는 복잡한 쿼리를 하나의 메서드로 요약하는 것입니다.
> - 예를들면 데이터베이스에서 정보를 추출하는 로직을 하나의 메서드로 요약하는 것입니다.
> - 개발자는 해당 메서드 하나만을 가지고도 복잡하게 구현된 기능을 간단하게 이용할 수 있습니다.
> - 예를들면 Java에서 기본적으로 제공하는 Scanner 클래스가 있습니다.

### 📌 추상화와 인터페이스의 관련성
> - 말 그대로 추상적인 개념인 추상화는 예시와 같이 클래스 또는 인터페이스로 구현됩니다.
> - 그중에서도 인터페이스는 클래스의 기능을 핵심 수단으로 사용합니다.
> - 개발자는 인터페이스를 이용하여 특정 클래스가 담당할 특정 기능을 정의할 수 있습니다.
> - 즉, 인터페이스의 모든 메서드는 추상 메서드이고 인터페이스에는 구체적인 로직이 없습니다.
> - 단, 하나의 클래스가 인터페이스를 사용할 때는 모든 메서드를 구체적으로 구현해야 됩니다.

### 📌 추상화 구현 예시
> - 추상화 구현의 예시를 들기 위해 상속, 추상화, 인터페이스 개념을 이용하였습니다.
> - Car 클래스는 추상 클래스인 Vehicle의 기능을 상속 받습니다.
> - Car 클래스는 Vehicle 클래스에 정의된 drive 메서드를 오버라이딩합니다.
> - Drivable 인터페이스는 drive 기능 실행을 담당하는 역할을 합니다.
> - Bicycle 클래스를 이용하여 Drivable 인터페이스를 구현(implements)하였습니다.

``` java
public class AbstractionTest {
	
	/* 추상 클래스 */
	// 추상 클래스는 이를 상속받는 클래스에 구현을 요구합니다.
	// Vehicle 추상 클래스를 정의하였습니다.
	public abstract class Vehicle {
		/* 추상 메서드 */
		// 추상 메서드는 이를 포함하는 클래스를 상속받는 클래스에서의 구현을 요구합니다.
		// drive 추상 메서드를 정의하였습니다.
		// 메서드에 기능은 없는 상태입니다.
		public abstract void drive();
		
		// start 메서드를 정의하였습니다.
		// '시동'이라는 문구를 출력합니다.
		public void start() {
			System.out.println("시동");
		}
	}
	
	/* 추상 클래스 상속 */
	// Vehicle 클래스를 상속시켰습니다.
	public class Car extends Vehicle {
		// drive 메서드 오버라이딩하였습니다.
		// drive 메서드에 기능을 부여하였습니다.
		// '운전'이라는 문구를 출력합니다.
		@Override
		public void drive() {
			System.out.println("차량 운전");
		}
	}
	
	/* 인터페이스 */
	// Drivable 인터페이스를 정의하였습니다.
	public interface Drivable {
		// drive 메서드를 정의하였습니다.
		// drive 메서드에 구현 내용은 없습니다.
		// 객체 지향 프로그래밍의 다형성 원리를 따라 drive 메서드 중복 문제는 없습니다.
		public void drive();
	}
	
	/* 인터페이스 구현 */
	public class Bicycle implements Drivable {
		@Override
		public void drive() {
			System.out.println("자전거 운전");
		}
	}

}
```

<br>

### 🔔 인터페이스(Interface)
### 📌 부제목
> - 글 내용

<br>

### 🔔 용어 정리
### 📌 추상 클래스
### 📌 추상 메서드

<br>
<br>
<br>
